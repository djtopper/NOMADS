import java.awt.*;
import java.lang.Math;
import java.applet.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.*;
import java.net.*;
import java.io.*;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import netscape.javascript.*;
import nomads.technosonics.*;

public class CloudDisplay extends Applet implements MouseListener, MouseMotionListener, ActionListener, Runnable {   

    private Socket socket              = null;
    private DataInputStream  console   = null;
    private DataOutputStream streamOut = null;
    private CloudDisplayThread client    = null;
    private String    serverName = globals.serverName;
    private int       serverPort = globals.serverPort;

    Random randNum;

    String imgPrefix;
    Image backgroundImg;
    URL imgWebBase;

    int t,i,j,clear, picker;
    int width,height,twidth,theight,fontSize, centerX, centerY;
    Font textFont;
    int startFontSize, minFontSize, maxFontSize;

    int tRow, tCol,rows,cols,tRows, tCols;
    int chatRows;

    int x,y,w,h,dx,dy,dw,dh,xVar,yVar;
    double xScale,yScale;

    double weightX, weightY, weight;
    int stringLength;
    int tPass, tNewFontSize;
    int wordFound;
    int tCloudColorNum;
    int maxCloudColors;
    int cloudA;

    Color textColor,backGroundColor;

    Color cloudColors[];

    JButton	clearButton;
    int mx, my; // recent mouse coords
    boolean isMouseDraggingBox = false;
    

    public class HistoElt {
	String text;  // The actual text we're printing
	int pass;  // What pass the word was entered (ie., time)
	int size, x, y, cols, quad;
	Font font;
	int r,g,b,a;
	Color color;
    }    
	
    // Number of times we've checked our global word list array
    int numPasses;
    
    // List of all our elements
    ArrayList<HistoElt> histoGram;
    //  Temporary placeholder
    HistoElt tHist;

    String text;
    int guesser,rGuess,cGuess;
	
	Image offScreen;
	Graphics2D offScreenGrp;
	Image player;
	
    public static void main(String args[])
    {
	/* DO: Change TUT_SineFreq to match the name of your class. Must match file name! */
	CloudDisplay  applet = new CloudDisplay();

	Frame appletFrame = new Frame("pollDisplay");

	appletFrame.add(applet);
	appletFrame.resize(600,600);
	appletFrame.show();

    }

    // public void setChatColors(int alpha) {
    // 	chatColors[0] = new Color(158, 55, 33, alpha);
    //   	chatColors[1] = new Color(145, 86, 65, alpha);
    //   	chatColors[2] = new Color(187, 137, 44, alpha);
    //   	chatColors[3] = new Color(191, 140, 44, alpha);
    //   	chatColors[4] = new Color(233, 158, 37, alpha);
    //   	chatColors[5] = new Color(242, 197, 126, alpha);
    //   	chatColors[6] = new Color(254, 205, 129, alpha);
    //   	chatColors[7] = new Color(249, 241, 131, alpha);
    //     }
    // 
    //     public void setCloudColors(int alpha) {
    // 	cloudColors[0] = new Color(158, 55, 33, alpha);
    //   	cloudColors[1] = new Color(145, 86, 65, alpha);
    //   	cloudColors[2] = new Color(187, 137, 44, alpha);
    //   	cloudColors[3] = new Color(191, 140, 44, alpha);
    //   	cloudColors[4] = new Color(233, 158, 37, alpha);
    //   	cloudColors[5] = new Color(242, 197, 126, alpha);
    //   	cloudColors[6] = new Color(254, 205, 129, alpha);
    //   	cloudColors[7] = new Color(249, 241, 131, alpha);
    //     }
    // 
    //     public void setPointerColors(int alpha) {
    // 	pointerColors[0] = new Color(158, 55, 33, alpha);
    //   	pointerColors[1] = new Color(145, 86, 65, alpha);
    //   	pointerColors[2] = new Color(187, 137, 44, alpha);
    //   	pointerColors[3] = new Color(191, 140, 44, alpha);
    //   	pointerColors[4] = new Color(233, 158, 37, alpha);
    //   	pointerColors[5] = new Color(242, 197, 126, alpha);
    //   	pointerColors[6] = new Color(254, 205, 129, alpha);
    //   	pointerColors[7] = new Color(249, 241, 131, alpha);
    //     }

    public void setCloudColors(int alpha) {
     	cloudColors[0] = new Color(158, 55, 33, alpha);
       	cloudColors[1] = new Color(145, 86, 65, alpha);
       	cloudColors[2] = new Color(187, 137, 44, alpha);
       	cloudColors[3] = new Color(191, 140, 44, alpha);
       	cloudColors[4] = new Color(233, 158, 37, alpha);
       	cloudColors[5] = new Color(242, 197, 126, alpha);
       	cloudColors[6] = new Color(254, 205, 129, alpha);
       	cloudColors[7] = new Color(249, 241, 131, alpha);
	maxCloudColors = 7;
    }

    public void init()
    {  	

	int i;

	imgPrefix = "http://nomads.music.virginia.edu/images/";
	
	try { 
	    imgWebBase = new URL(imgPrefix); 
	} 
        catch (Exception e) {}
	

	randNum = new Random();

	width = getSize().width;
	height = getSize().height;

	offScreen = createImage(width,height);
	offScreenGrp = (Graphics2D) offScreen.getGraphics();
	backgroundImg = getImage(imgWebBase,"SandDunes1_950x650.jpg");

	offScreenGrp.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);


	centerX = (width/2);
	centerY = (height/2); 

	globals.cPrint("width = " + width + "height = " + height);
	setBackground(Color.black);	

	cloudColors = new Color[8];
	cloudA = 230;
	setCloudColors(cloudA);
	int tCloudColorNum = 0;
	int maxCloudColors = 7;

	i = 0;
	j = 0;
	clear = 0;

	xScale = 0.3;
	yScale = 0.3;
	
	histoGram = new ArrayList<HistoElt>();
	
	wordFound = 0;
	numPasses = 0;
	startFontSize = 25;
	minFontSize = 10;
	maxFontSize = 200;

	x = width / 2 - 20;
	y = height / 2 - 20;
	
	addMouseListener(this);
	addMouseMotionListener(this);

	connect(serverName, serverPort);
    }	
	
    public void connect(String serverName, int serverPort)
    {  
	System.out.println("Establishing connection. Please wait ...");
	try {  
	    socket = new Socket(serverName, serverPort);	

	    System.out.println("Connected");
	    open();
	}
	catch(UnknownHostException uhe) {  
	    System.out.println("How unknown");
	}
	catch(IOException ioe) {  
	    System.out.println("Unexpected exception: ");
	} 
    }

    public void mouseEntered(MouseEvent e) {
    }
    
    public void mouseExited(MouseEvent e) {
    }
    
    public void mouseClicked(MouseEvent e) {
    }
    
    public void mousePressed(MouseEvent e) {
	mx = e.getX();
	my = e.getY();
	if (x < mx && mx < x + 40 && y < my && my < y + 40) {
	    isMouseDraggingBox = true;
	}
	e.consume();
    }

    public void mouseReleased(MouseEvent e) {
	/*if (isMouseDraggingBox) {
	  try {
	  double myx = (mx - (width / 2)) / ((double) width * 3);
	  double myy = (my - (height / 2)) / ((double) height * 3);
	  String towrite = "move" + " " + personnum + " " + myx + " "
	  + myy;
	  System.out.println("Byte is " + app_id.STUDENT_SAND_POINTER + " and write is "
	  + towrite);
	  streamOut.writeByte(app_id.STUDENT_SAND_POINTER);
	  streamOut.writeUTF(towrite);
	  } catch (IOException ioe) {
	  System.out.println("Error writing...");
	  }
	  }*/
	isMouseDraggingBox = false;
	e.consume();
    }
    
    public void mouseMoved(MouseEvent e) {
    }

    public void mouseDragged(MouseEvent e) {
	if (isMouseDraggingBox) {
	    // get the latest mouse position
	    int new_mx = e.getX();
	    int new_my = e.getY();
	    
	    // displace the box by the distance the mouse moved since the last
	    // event
	    // Note that "x += ...;" is just shorthand for "x = x + ...;"
	    if (new_mx < 5)
		new_mx = 5;
	    if (new_mx > 890)
		new_mx = 890;
	    if (new_my < 5)
		new_my = 5;
	    if (new_my > 590)
		new_my = 590;

	    x += new_mx - mx;
	    y += new_my - my;

	    // update our data
	    mx = new_mx;
	    my = new_my;
	    
	    
	    repaint();
	    e.consume();
	}
    }

    // ------------------------------------------------------------------------------------------------
    // BEGIN handle()
    // ------------------------------------------------------------------------------------------------

    public void handle(byte bite, String text) {
	int i,j,fc,sc,x,y,quad,lastQuad;
	float freq,amp;
	String temp,tAlpha,thread,input, tTest;
	int THREAD_ID;
	float xput,yput;

	quad=0;
	lastQuad=0;
	
	tTest = text; 
	
	if (text.length() >= 4){
	    tTest = text.substring(0, 4);
	    globals.cPrint("tTest =" + tTest);
	}
	globals.cPrint("...");
	globals.cPrint("handle(" + text + "," + bite + ") [CloudDisplay]\n");
	globals.cPrint("...");
	    
	// if (text.equals(".bye")) {
	//     System.out.println("Bye!");
	//     close(); 
	// }
	
	// ========= CLOUD INPUT ============================================

	if (bite == app_id.CLOUD_CHAT) {
	    
	    globals.cPrint("CLOUD_CHAT\n");
	    
	    stringLength = text.length(); 
	    
	    // Then check text locations to avoid collisions *************************
	    
	    wordFound = 0;
	    
	    // Check our histogram =============================================
	    
	    for (i=0;i<histoGram.size();i++) {
		tHist = histoGram.get(i);
		globals.cPrint("...");
		globals.cPrint("checking histogram ----- tHist.text = ||>> " + tHist.text + " <<||");
		globals.cPrint("...");
		globals.cPrint("  tHist.size = " + tHist.size);
		globals.cPrint("...");
		globals.cPrint(" histoGram.size() = " + histoGram.size());
		
		// 1.  Histogram element [i] matches incoming text -----
		
		x=tHist.x;
		y=tHist.y;	       	
		
		if (tHist.text.compareToIgnoreCase(text) == 0) {
		    wordFound = 1;
		    globals.cPrint("...");
		    globals.cPrint(">>>FOUND " + tHist.text + " at [" + x + "]" + "[" + y + "]");
		    globals.cPrint("  INCreasing text size");
		    
		    // This will change to be a combination of rank v time (ie., numPasses);
		    tHist.size += 4;

		    quad = tHist.quad;
		    globals.cPrint("  quad = " + quad);
		    // if (quad > 75) {
		    // 	tHist.x-=8;
		    // 	tHist.y-=5;
		    // 	if (tHist.x < centerX)
		    // 	    tHist.x = centerX;
		    // 	if (tHist.y < centerY)
		    // 	    tHist.y = centerY;
		    // }
		    // else if (quad > 50) {
		    // 	tHist.x-=8;
		    // 	tHist.y+=5;
		    // 	if (tHist.x < centerX)
		    // 	    tHist.x = centerX;
		    // 	if (tHist.y > centerY)
		    // 	    tHist.y = centerY;
		    // }
		    // else if (quad > 25) {
		    // 	tHist.x+=6;
		    // 	tHist.y+=5;
		    // 	if (tHist.x > centerX)
		    // 	    tHist.x = centerX;
		    // 	if (tHist.y > centerY)
		    // 	    tHist.y = centerY;
		    // }
		    // else {
		    // 	tHist.x+=6;
		    // 	tHist.y-=5;
		    // 	if (tHist.x > centerX)
		    // 	    tHist.x = centerX;
		    // 	if (tHist.y < centerY)
		    // 	    tHist.y = centerY;
		    // }

		    if (tHist.size > maxFontSize) {
			fontSize = maxFontSize;
		    }
		    else {
			fontSize = tHist.size;
		    }
		    tHist.font = new Font("Helvetica", Font.PLAIN, fontSize);
		    
		    //i = histoGram.size();  // exit the loop
		    
		}
		
		// 2a.  Blank cell ... do nothing
		else if (tHist.text.compareToIgnoreCase("") == 0) {
		    globals.cPrint("|_|");
		}
		
		// 2.  Histogram element [i] DOES NOT match incoming text and is > min size -----
		
		else if (tHist.size > minFontSize) {  // Decrease size (if > min AND modulo 2)
		    globals.cPrint("...");
		    globals.cPrint("  DECreasing word size for " + tHist.text);
		    globals.cPrint("...");
		    globals.cPrint("  numPasses = " + numPasses);
		    if (numPasses%2 == 0) {
			tHist.size--;
			// quad = tHist.quad;
			// if (quad > 75) {
			//     tHist.x+=2;
			//     tHist.y+=2;
			// }
			// else if (quad > 50) {
			//     tHist.x+=2;
			//     tHist.y-=2;
			// }
			// else if (quad > 25) {
			//     tHist.x-=2;
			//     tHist.y-=2;
			// }
			// else {
			//     tHist.x-=2;
			//     tHist.y+=2;
			// }
			// if (tHist.x < 10) 
			//     tHist.x = 10;
			// if (tHist.x > (width-10))
			//     tHist.x = width-10;
			// if (tHist.y < 10) 
			//     tHist.y = 10;
			// if (tHist.y > (height-10))
			//     tHist.y = height-10;
		    }
		    if (tHist.size > maxFontSize)
			tHist.size = maxFontSize;
		    fontSize = tHist.size;
		    tHist.font = new Font("Helvetica", Font.PLAIN, fontSize);

		    globals.cPrint("...");

		    globals.cPrint("  tHist.x,tHist.y = " + tHist.x + "," + tHist.y);
		    globals.cPrint("...");
		    globals.cPrint("  tHist.size= " + tHist.size);
		}
			
		// 3.  Histogram element [i] DOES NOT match and is < min size ... delete it
			
		else if (tHist.size <= minFontSize) {
		    globals.cPrint("...");
		    globals.cPrint("  tHist.x,tHist.y = " + tHist.x + "," + tHist.y);
		    globals.cPrint("...");
		    globals.cPrint("  tHist.size= " + tHist.size);
		    globals.cPrint("...");
		    globals.cPrint("  REMoving word: " + tHist.text + "<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
				
		    fontSize = tHist.size;
		    if (fontSize < minFontSize)
			fontSize = minFontSize;

		    histoGram.remove(i);
		    i--;
		}			  	
	    }  // end for (i=0;i<histoGram.size();i++)
		

	    // No words found, add new word and store relevant data
	    if (wordFound == 0) {
		// Figure out where to put the text =============================================
			
		// Find a free cell
		picker = 1;
		
		globals.cPrint("...");

		// figure out center, then expand range over time 
		
		x=y=0;

		tHist = new HistoElt();
		tHist.text = new String(text);
	
		int xMin = 0; // (int)(width * 0.2);
		int xVar = (int)(width * xScale);
		xScale += 0.1;
		if (xScale > 0.5) 
		    xScale = 0.3;

		int yMin = 0; // (int)(height * 0.2);
		int yVar = (int)(height * yScale);
		yScale += 0.1;
		if (yScale > 0.5)
		    yScale = 0.3;
		
		lastQuad = quad;
		quad = randNum.nextInt(5);
		while (quad == lastQuad) {
		    quad = randNum.nextInt(5);
		}
		tHist.quad = quad;
		globals.cPrint(">>>NEW WORD " + tHist.text + " at [" + x + "]" + "[" + y + "]");
		globals.cPrint("setting quad = " + quad);

		int xRand = xMin + randNum.nextInt(xVar);
		int yRand = yMin + randNum.nextInt(yVar);
		
		if (quad > 3) {
		    x = centerX + xRand;
		    y = centerY + yRand;
		}
		else if (quad > 2) {
		    x = centerX + xRand;
		    y = centerY - yRand;
		}
		else if (quad > 1) {
		    x = centerX - xRand;
		    y = centerY - yRand;
		}
		else  {
		    x = centerX - xRand;
		    y = centerY + yRand;
		}
		
		// if ((x > centerX) && (y > centerY)) {
		//     quad = 3;
		// }
		// if ((x > centerX) && (y < centerY)) {
		//     quad = 2;
		// }
		// if ((x < centerX) && (y < centerY)) {
		//     quad = 1;
		// }
		// if ((x < centerX) && (y > centerY)) {
		//     quad = 0;
		// }
		// tHist.quad = quad;

		globals.cPrint("<<<< ADDING new word: " + text + " at " + "[" + x + "]" + "[" + y + "]");


		tCloudColorNum++;
		if (tCloudColorNum > maxCloudColors)
		    tCloudColorNum = 0;	
		tHist.color = cloudColors[tCloudColorNum]; 	
		tHist.color = Color.black;

		fontSize = tHist.size = startFontSize;
		tHist.pass = numPasses;
		
		tHist.x = x;
		tHist.y = y;
		
		tHist.font = new Font("Helvetica", Font.PLAIN, tHist.size);
		histoGram.add(tHist);
		
		// This will change to be a combination of rank v time (ie., numPasses);
		
		// DRAW THE TEXT ======================================

		globals.cPrint("...");
		globals.cPrint("Drawing word: " + text);

	    }
	    
	    // CODE TO CLEAR THE SCREEN, NOT USED AS OF 2/15/2010 ============================
	    //**** If we fill up the cells they clear SK 12/03/09
	    //****Ultimately we should make a button that does this
	    
	    clear = 0;
	    if (clear == 1) {
		globals.cPrint("CLEAR!");
		histoGram.clear();
		clear = 0;
		i = 0;
		j = 0;
		clear = 0;
		guesser = 0;		
		globals.cPrint("CLEAR:  clearing rows/cols");
	    }
		
	    // END CLEAR CODE ==================================================================
		
	    numPasses++;
	    globals.cPrint("...");
	    globals.cPrint("END handle(" + text + ") numPasses = " + numPasses + " -----");
	    repaint();
	}
	// END OC_CLOUD ------------------------------------------------------------------------------------

	if (bite == app_id.MONITOR) {
	    if (text.equals("CHECK")) {
		try {
		    streamOut.writeByte((byte)app_id.MONITOR);
		    streamOut.writeUTF("PING");
		}
		catch(IOException ioe) {
		    System.out.println("Error writing to output stream: ");
		}
	    }	 
	}   
	globals.cPrint ("-------------------------------------------------[OM]\n");
    }

    // ------------------------------------------------------------------------------------------------
    // END handle()
    // ------------------------------------------------------------------------------------------------
	
    public void actionPerformed( ActionEvent ae )
    {
	Object obj = ae.getSource();
	if( obj == clearButton ) {
	    globals.cPrint("You pressed clear");
	    globals.cPrint("...");
	    globals.cPrint("actionPerformed():  clearing histogram");
	    for (i=0;i<histoGram.size();i++) {
		
		globals.cPrint("...");
		String tempString = Integer.toString(histoGram.size());
		
		globals.cPrint(tempString);
		tHist = histoGram.get(i);
		tHist.pass = 0;
		x=tHist.x;
		y=tHist.y;
		tHist.font = new Font("Helvetica", Font.PLAIN, startFontSize);
	    }
	    globals.cPrint("CLEAR!");
	    histoGram.clear();
	    clear = 0;
	    i = 0;
	    j = 0;
	    clear = 0;
	    guesser = 0;		
	    globals.cPrint("...");
	    globals.cPrint("actionPerformed():  clearing rows/cols");
	}
		
    }
	
    public void open()
    {  
	globals.cPrint("...");
	globals.cPrint("open()");
	try {
	    globals.cPrint("Sending app_id byte and null string.");
	    streamOut = new DataOutputStream(socket.getOutputStream());
	    client = new CloudDisplayThread(this, socket);
	    streamOut.writeByte((byte)app_id.CLOUD_DISPLAY);
	    streamOut.writeUTF("");
	}
	catch(IOException ioe) {
	    System.out.println("Error opening output stream: ");
	} 
    }
    public void close()
    {  
	try {
	    streamOut.writeByte((byte)app_id.CLOUD_DISPLAY);
	    streamOut.writeUTF("");
	    streamOut.flush();
	    if (streamOut != null)  streamOut.close();
	    if (socket    != null)  socket.close(); 
	}
	catch(IOException ioe) {
	    System.out.println("Error closing...");
	}
	client.close();  
	client.stop(); 
    }
	

    public void getParameters() {
	serverName = "nomads.music.virginia.edu";
	serverPort = 52807; 
    }

    // DT 6/30/10:  not sure we need these anymore

    public void start() {

    }

    public void run () {
	if (i == 1) {
	} 
    }

    public void paint(Graphics g) {
	int tx, ty, r,gr,b,a;
	Color tc;
	int len1,len2;
	int ksize = 7;
	int ssize = 5;

	// g.dispose();
	// setBackground(Color.black);
	// g.setColor(Color.black);
	super.paint(g);
	// setBackground(Color.black);
	// g.setColor(Color.black); //STK here's where to change the background color
	// g.drawImage(image, 0, 0, width, height, this);
	//g.drawImage(backgroundImg, 0, 0, width, height, this);
	offScreenGrp.drawImage(backgroundImg, 0, 0, width, height, this);

	//g.fillRect(0,0,width,height);

	//	setBackground(Color.black);

	for (i=0;i<histoGram.size();i++) {
	    tHist = histoGram.get(i);

	    r = tHist.color.getRed();
	    gr = tHist.color.getGreen();
	    b = tHist.color.getBlue();
	    a = cloudA;

	    tc = new Color(r,gr,b,a);
    
    	offScreenGrp.setColor(tc);
    	offScreenGrp.setFont(tHist.font);
	    offScreenGrp.drawString(tHist.text, tHist.x, tHist.y);
	    // g.setColor(tc);
// 	    g. setFont(tHist.font);
// 	    g.drawString(tHist.text, tHist.x, tHist.y);

	}
		g.drawImage(offScreen, 0, 0, width, height, this);

    }

}
